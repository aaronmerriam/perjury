import random
import copy
import datetime

from itertools import repeat


class BaseGenerator(object):
    """
    Base class for all pyrite generator classes.
    """
    size = None
    unique = True
    shuffle = True

    def __init__(self, size=None, unique=None, shuffle=None):
        self.hashes = set()
        self.size = size or self.size
        self.unique = unique or self.unique
        self.shuffle = shuffle or self.shuffle

    def __len__(self):
        return self.size

    def compute_hash(self, value):
        """
        Hook for ensuring unique results.
        """
        return value

    def inner_generator(self):
        """
        Hook for subclasses of `BaseGenerator`.

        When possible, subclasses should return an infinite generator, as the
        ``inner_generator`` and ``__iter__`` methods handle limiting the number
        of resulds generated by the generator class.
        """
        raise NotImplementedError('Genertator classes must implement their own `inner_generator` method.')

    def outer_generator(self):
        """
        In the case of a fixed size, this returns an iterator which will
        terminate after ``self.size`` iterations.

        In the case of ``self.size`` being ``None``, this will return an
        infinite generator
        """
        if self.size is None:
            while True:
                yield
        else:
            for i in xrange(self.size):
                yield i

    def __iter__(self):
        """
        Implements the actual generation, limiting based on ``self.size`` if
        present, and ensuring that unique values are returned if
        ``self.unique`` is set to ``True``.
        """
        generator = self.inner_generator()
        for i in self.outer_generator():
            # Enter an infinite loop, allowing us to ensure values are unique
            # if self.unique is set to true
            while True:
                retval = generator.next()
                hash = self.compute_hash(retval)
                # Break if the hash for this return value is in self.hashes.
                if not hash in self.hashes:
                    break
            # If unique return values are being enforced, add the hash to
            # self.hashes.  Otherwise, leaving it out will allow for duplicate
            # return values.
            if self.unique:
                self.hashes.add(hash)
            yield retval


class WordGenerator(BaseGenerator):
    """
    Generates results based on a wordlist stored in self.words.
    """
    words = []

    def __init__(self, size=None, **kwargs):
        kwargs['size'] = size or len(self.words)
        super(WordGenerator, self).__init__(**kwargs)
        self.words = copy.copy(self.words)
        if self.shuffle:
            # Make the list of words mutable if it appears to be immutable
            if not hasattr(self.words, '__setitem__'):
                self.words = list(self.words)
            random.shuffle(self.words)

    def inner_generator(self):
        return iter(self.words)

    def __getitem__(self, key):
        return self.words[key]


class MultiGenerator(BaseGenerator):
    """
    Uses multiple generators to generate a string formatted value
    """
    generators = {}
    generator_classes = []
    format_string = None

    def __init__(self, size):
        super(MultiGenerator, self).__init__(size)
        for key, GeneratorClass in self.generator_classes.iteritems():
            self.generators[key] = iter(GeneratorClass(self.size))

    def inner_generator(self):
        while True:
            kwargs = self.get_format_kwargs()
            retval = self.format_string.format(**kwargs)
            yield retval

    def get_format_kwargs(self):
        """
        Returns a dictionary to be used in string formatting.
        """
        kwargs = {}
        for key, generator in self.generators.iteritems():
            kwargs[key] = generator.next()
        return kwargs


class RepeatValueGenerator(BaseGenerator):
    """
    Generates the same value over and over.  This is simply a wrapper around ``itertools.repeat``.
    """
    unique = False
    value = None

    def inner_generator(self):
        return repeat(self.value)


class IntegerGenerator(BaseGenerator):
    """
    Generates integers.

    If ``shuffle`` is set to ``False``, the generator will loop over the number range until termination.
    """
    unique = False
    lower_bound = 0
    upper_bound = 1000

    def __init__(self, *args, **kwargs):
        for field_name in ['lower_bound', 'upper_bound']:
            value = kwargs.pop(field_name, None)
            if value is not None:
                setattr(self, field_name, int(value))
        super(IntegerGenerator, self).__init__(*args, **kwargs)
        if self.unique and self.size > abs(self.upper_bound - self.lower_bound):
            raise ValueError('Impossible constraints.  Either disable uniqueness on this generator, or increase the bounds')

    def inner_generator(self):
        while True:
            if self.shuffle:
                yield random.randint(self.lower_bound, self.upper_bound)
            else:
                for i in xrange(self.lower_bound, self.upper_bound):
                    yield i


class RandomChoiceGenerator(BaseGenerator):
    """
    Generates a random choice from a pre-defined list of choices.
    """
    unique = False
    values = []

    def inner_generator(self):
        while True:
            yield random.choice(self.values)


class DateTimeGenerator(BaseGenerator):
    """
    Base class for date generation.
    """
    # TODO: make shuffle do something.  Equally spaced ordered dates possibly?
    min_datetime = datetime.datetime.min
    max_datetime = datetime.datetime.max

    def get_min_datetime(self):
        return self.min_datetime

    def get_max_datetime(self):
        return self.max_datetime

    def inner_generator(self):
        while True:
            delta = self.get_max_datetime() - self.get_min_datetime()
            return self.min_datetime + datetime.timedelta(random.randrange(delta.total_seconds()))
